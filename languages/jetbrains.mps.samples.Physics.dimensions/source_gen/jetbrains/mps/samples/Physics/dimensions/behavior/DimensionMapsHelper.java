package jetbrains.mps.samples.Physics.dimensions.behavior;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import org.nevec.rjm.Rational;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class DimensionMapsHelper {

  /**
   * Returns true if both maps of units contains the same exponents
   */
  public static boolean matches(Map<SNode, Rational> left, final Map<SNode, Rational> right) {
    return MapSequence.fromMap(left).count() == MapSequence.fromMap(right).count() && MapSequence.fromMap(left).all(new IWhereFilter<IMapping<SNode, Rational>>() {
      public boolean accept(IMapping<SNode, Rational> it) {
        return MapSequence.fromMap(right).containsKey(it.key()) && MapSequence.fromMap(right).get(it.key()).compareTo(it.value()) == 0;
      }
    });
  }


  /**
   * Display the given map in a readable format such as m^2 * s^-1
   */
  public static String mapToString(Map<SNode, Rational> map) {
    Iterable<String> seq = MapSequence.fromMap(map).select(new ISelector<IMapping<SNode, Rational>, String>() {
      public String select(IMapping<SNode, Rational> it) {
        return SPropertyOperations.getString(it.key(), PROPS.name$MnvL) + "^" + it.value().toString();
      }
    });
    return Sequence.fromIterable(seq).skip(1).foldLeft(Sequence.fromIterable(seq).first(), new ILeftCombinator<String, String>() {
      public String combine(String s, String it) {
        return s + " * " + it;
      }
    });
  }


  /**
   * Convert the map back to references
   */
  public static Iterable<SNode> mapToReferences(Map<SNode, Rational> map) {
    return MapSequence.fromMap(map).where(new IWhereFilter<IMapping<SNode, Rational>>() {
      public boolean accept(IMapping<SNode, Rational> it) {
        return it != null && it.value().compareTo(Rational.ZERO) != 0;
      }
    }).select(new ISelector<IMapping<SNode, Rational>, SNode>() {
      public SNode select(IMapping<SNode, Rational> it) {
        return createDimensionReference_6b7pfp_a0a0a0a0h(it.key(), ExponentHelper.rationalToExponent(it.value()));
      }
    });
  }


  /**
   * Combine values depending on the basic operations
   */
  public static Map<SNode, Rational> combine(Map<SNode, Rational> left, Map<SNode, Rational> right, SNode operation) throws UnitComputationException {

    if (SNodeOperations.isInstanceOf(operation, CONCEPTS.PlusExpression$mx) || SNodeOperations.isInstanceOf(operation, CONCEPTS.MinusExpression$6z)) {
      if (matches(left, right)) {
        return left;
      } else {
        throw new UnitComputationException("Unmatched units: " + mapToString(left) + " and " + mapToString(right));
      }
    }

    if (SNodeOperations.isInstanceOf(operation, CONCEPTS.MulExpression$iC)) {
      DimensionMapsHelper.multiplyAndMergeInto(left, new Rational(1), right);
      return right;
    }

    if (SNodeOperations.isInstanceOf(operation, CONCEPTS.DivExpression$us)) {
      DimensionMapsHelper.multiplyAndMergeInto(right, new Rational(-1), left);
      return left;
    }

    if (SNodeOperations.isInstanceOf(operation, CONCEPTS.BinaryComparisonExpression$7z) && !(matches(left, right))) {
      throw new UnitComputationException("Unmatched units: " + mapToString(left) + " and " + mapToString(right));
    }

    return null;
  }

  public static void multiply(Map<SNode, Rational> sourceMap, final Rational exponent) {
    MapSequence.fromMap(sourceMap).visitAll(new IVisitor<IMapping<SNode, Rational>>() {
      public void visit(IMapping<SNode, Rational> it) {
        it.value(it.value().multiply(exponent));
      }
    });
  }

  /**
   * Multiply the source map values by a factor, then add all result in the target map
   */
  public static void multiplyAndMergeInto(Map<SNode, Rational> sourceMap, final Rational exponent, final Map<SNode, Rational> targetMap) {
    // Multiply the power of the child units by it's power
    MapSequence.fromMap(sourceMap).visitAll(new IVisitor<IMapping<SNode, Rational>>() {
      public void visit(IMapping<SNode, Rational> it) {
        Rational power = it.value().multiply(exponent);

        // Add it to the map
        if (MapSequence.fromMap(targetMap).containsKey(it.key())) {
          MapSequence.fromMap(targetMap).put(it.key(), MapSequence.fromMap(targetMap).get(it.key()).add(power));
        } else {
          MapSequence.fromMap(targetMap).put(it.key(), power);
        }
      }
    });
  }

  private static SNode createDimensionReference_6b7pfp_a0a0a0a0h(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.DimensionReference$6u);
    n0.setReferenceTarget(LINKS.unit$5Sm, p0);
    n0.forChild(LINKS.exponent$5qk).initNode(p1, CONCEPTS.Exponent$Yg, true);
    return n0.getResult();
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PlusExpression$mx = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c9a4f2L, "org.iets3.core.expr.base.structure.PlusExpression");
    /*package*/ static final SConcept MinusExpression$6z = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cac5a5L, "org.iets3.core.expr.base.structure.MinusExpression");
    /*package*/ static final SConcept MulExpression$iC = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c9a56fL, "org.iets3.core.expr.base.structure.MulExpression");
    /*package*/ static final SConcept DivExpression$us = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cac63bL, "org.iets3.core.expr.base.structure.DivExpression");
    /*package*/ static final SConcept BinaryComparisonExpression$7z = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cb4f93L, "org.iets3.core.expr.base.structure.BinaryComparisonExpression");
    /*package*/ static final SConcept DimensionReference$6u = MetaAdapterFactory.getConcept(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x2c25ac8bca7e6b7cL, "jetbrains.mps.samples.Physics.dimensions.structure.DimensionReference");
    /*package*/ static final SConcept Exponent$Yg = MetaAdapterFactory.getConcept(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x34c38940d07a6995L, "jetbrains.mps.samples.Physics.dimensions.structure.Exponent");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink unit$5Sm = MetaAdapterFactory.getReferenceLink(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c0465feb9L, 0x777af24c0465febcL, "unit");
    /*package*/ static final SContainmentLink exponent$5qk = MetaAdapterFactory.getContainmentLink(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c0465feb9L, 0x777af24c0465febaL, "exponent");
  }
}
