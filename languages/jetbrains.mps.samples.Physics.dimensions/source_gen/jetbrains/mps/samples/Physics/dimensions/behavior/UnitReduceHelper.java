package jetbrains.mps.samples.Physics.dimensions.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import org.nevec.rjm.Rational;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterBaseException;
import jetbrains.mps.samples.Physics.dimensions.typesystem.NumberTypeHelper;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class UnitReduceHelper {

  /**
   * Combine node types used in an expression
   */
  public static SNode combine(SNode left, SNode right, SNode operator) {
    SNode leftBaseType = getBaseType(left);
    SNode rightBaseType = getBaseType(right);

    SNode baseOperationType = TypeChecker.getInstance().getRulesManager().getOperationType(operator, leftBaseType, rightBaseType);

    if (baseOperationType == null) {
      return createRuntimeErrorType_5s5y64_a0a5a1();
    } else {
      SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c04609bcaL, "jetbrains.mps.samples.Physics.dimensions.structure.DimensionType"));
      SLinkOperations.setTarget(result, LINKS.baseType$mnRO, SNodeOperations.cast(baseOperationType, CONCEPTS.Type$WK));

      try {
        // Compute units on both sides (could throw runtime exception)
        Map<SNode, Rational> leftUnits = reduceUnits(SLinkOperations.getChildren(SNodeOperations.as(left, CONCEPTS.DimensionType$8R), LINKS.units$qq1O));
        Map<SNode, Rational> rightUnits = reduceUnits(SLinkOperations.getChildren(SNodeOperations.as(right, CONCEPTS.DimensionType$8R), LINKS.units$qq1O));

        // Combine them (can throw unit computation exception)
        Map<SNode, Rational> combination = DimensionMapsHelper.combine(leftUnits, rightUnits, operator);

        // Set the result
        ListSequence.fromList(SLinkOperations.getChildren(result, LINKS.units$qq1O)).addSequence(Sequence.fromIterable(DimensionMapsHelper.mapToReferences(combination)));
      } catch (UnitComputationException | InterpreterBaseException e) {
        return createRuntimeErrorType_5s5y64_a0a0d0a5a1(e.getMessage());
      }

      // If no resulting units (exponent = 0 or boolean expression)
      return (ListSequence.fromList(SLinkOperations.getChildren(result, LINKS.units$qq1O)).isEmpty() ? baseOperationType : result);
    }
  }


  /**
   * Combine a value with dimension with a constant (no dimension)
   */
  public static SNode combineWithConstant(SNode dimension, SNode constant, SNode operator, boolean constantIsLeft) {

    // Multiplication and division by a factor
    if (SNodeOperations.isInstanceOf(operator, CONCEPTS.MulExpression$iC)) {
      return createDimensionType_5s5y64_a0a2a4(SNodeOperations.as(TypeChecker.getInstance().getRulesManager().getOperationType(operator, SLinkOperations.getTarget(dimension, LINKS.baseType$mnRO), constant), CONCEPTS.Type$WK), SLinkOperations.getChildren(dimension, LINKS.units$qq1O));
    } else if (SNodeOperations.isInstanceOf(operator, CONCEPTS.DivExpression$us)) {
      // Depending on a 0 position, might divide by 0
      if ((!(constantIsLeft) && NumberTypeHelper.isBaseTypeZero(constant)) || (constantIsLeft && NumberTypeHelper.isBaseTypeZero(dimension))) {
        return createRuntimeErrorType_5s5y64_a0a1a0c0e();
      }

      List<SNode> targetUnits = SLinkOperations.getChildren(SNodeOperations.copyNode(dimension), LINKS.units$qq1O);
      if (constantIsLeft) {
        // Reverse units
        ListSequence.fromList(targetUnits).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SLinkOperations.setTarget(it, LINKS.exponent$5qk, ExponentHelper.rationalToExponent(IUnitReferenceLike__BehaviorDescriptor.getRawExponent_id3031Xnpas0C.invoke(it).negate()));
          }
        });
      }

      return createDimensionType_5s5y64_a6a0c0e(SNodeOperations.as(TypeChecker.getInstance().getRulesManager().getOperationType(operator, SLinkOperations.getTarget(dimension, LINKS.baseType$mnRO), constant), CONCEPTS.Type$WK), targetUnits);
    }

    // If the constant was not handled and is zero, we apply the same units
    if (NumberTypeHelper.isZero(constant)) {
      // Default behavior : consider the zero type as same dimension
      return combine(dimension, dimension, operator);
    }

    return null;
  }

  public static SNode getBaseType(SNode type) {
    {
      final SNode node = type;
      if (SNodeOperations.isInstanceOf(node, CONCEPTS.DimensionType$8R)) {
        return SLinkOperations.getTarget(node, LINKS.baseType$mnRO);
      }
    }

    return type;
  }


  /**
   * Get all the units in the form of a map, only the most simple units are used
   * (complex units are turned back into their simple parts, for example :
   * 1 mps -> 1 m^1*s^-1)
   */
  public static Map<SNode, Rational> reduceUnits(Iterable<SNode> units) {
    final Map<SNode, Rational> result = MapSequence.fromMap(new HashMap<SNode, Rational>());
    Sequence.fromIterable(units).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        DimensionMapsHelper.multiplyAndMergeInto(Dimension__BehaviorDescriptor.getRawTypes_id3yBD53WvLzq.invoke(SLinkOperations.getTarget(it, LINKS.unit$5Sm)), IUnitReferenceLike__BehaviorDescriptor.getRawExponent_id3031Xnpas0C.invoke(it), result);
      }
    });
    return result;
  }

  public static Iterable<SNode> reduceUnitsToReferences(Iterable<SNode> units) {
    return DimensionMapsHelper.mapToReferences(reduceUnits(units));
  }
  private static SNode createRuntimeErrorType_5s5y64_a0a5a1() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_5s5y64_a0a0d0a5a1(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }
  private static SNode createDimensionType_5s5y64_a0a2a4(SNode p0, Iterable<? extends SNode> p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.DimensionType$8R);
    n0.forChild(LINKS.baseType$mnRO).initNode(p0, CONCEPTS.Type$WK, true);
    n0.forChild(LINKS.units$qq1O).initNodeList(p1, CONCEPTS.DimensionReference$6u);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_5s5y64_a0a1a0c0e() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, "division by 0");
    return n0.getResult();
  }
  private static SNode createDimensionType_5s5y64_a6a0c0e(SNode p0, Iterable<? extends SNode> p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.DimensionType$8R);
    n0.forChild(LINKS.baseType$mnRO).initNode(p0, CONCEPTS.Type$WK, true);
    n0.forChild(LINKS.units$qq1O).initNodeList(p1, CONCEPTS.DimensionReference$6u);
    return n0.getResult();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink baseType$mnRO = MetaAdapterFactory.getContainmentLink(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c04609bcaL, 0x777af24c04609bcbL, "baseType");
    /*package*/ static final SContainmentLink units$qq1O = MetaAdapterFactory.getContainmentLink(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c04661544L, 0x777af24c04661545L, "units");
    /*package*/ static final SContainmentLink exponent$5qk = MetaAdapterFactory.getContainmentLink(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c0465feb9L, 0x777af24c0465febaL, "exponent");
    /*package*/ static final SReferenceLink unit$5Sm = MetaAdapterFactory.getReferenceLink(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c0465feb9L, 0x777af24c0465febcL, "unit");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Type$WK = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
    /*package*/ static final SConcept DimensionType$8R = MetaAdapterFactory.getConcept(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x777af24c04609bcaL, "jetbrains.mps.samples.Physics.dimensions.structure.DimensionType");
    /*package*/ static final SConcept MulExpression$iC = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c9a56fL, "org.iets3.core.expr.base.structure.MulExpression");
    /*package*/ static final SConcept DivExpression$us = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cac63bL, "org.iets3.core.expr.base.structure.DivExpression");
    /*package*/ static final SConcept RuntimeErrorType$3c = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, "jetbrains.mps.lang.typesystem.structure.RuntimeErrorType");
    /*package*/ static final SConcept DimensionReference$6u = MetaAdapterFactory.getConcept(0x3571bff8cf914cd7L, 0xb8b7baa06abadf7cL, 0x2c25ac8bca7e6b7cL, "jetbrains.mps.samples.Physics.dimensions.structure.DimensionReference");
  }

  private static final class PROPS {
    /*package*/ static final SProperty errorText$leWQ = MetaAdapterFactory.getProperty(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, 0x113f84956faL, "errorText");
  }
}
