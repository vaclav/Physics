package jetbrains.mps.samples.Physics.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.dependencies.InferenceMethod;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.samples.Physics.dimensions.typesystem.NumberTypeHelper;
import org.iets3.core.expr.base.typesystem.TypingHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.errors.IRuleConflictWarningProducer;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;

public class TypeComparisonHelper {

  /**
   * Assert whether the two given numeric types are comparable, allow a zero to be compared to any kind of number (including dimensions)
   * 
   * iets3.opensource does not make use of the :~: operator, this method offer a simple replacement
   * 
   * 
   * @see org.iets3.core.expr.base.typesystem.TypingHelper 
   * @param leftName callback in case of error
   */
  @InferenceMethod
  public static void assertComparable(final TypeCheckingContext typeCheckingContext, SNode left, SNode right, final String leftName, final String rightName, final _FunctionTypes._void_P1_E0<? super String> errorStringCallback) {
    final SNode leftType = SNodeOperations.as(left, CONCEPTS.Type$fA);
    final SNode rightType = SNodeOperations.as(right, CONCEPTS.Type$fA);

    //  Allow 0 as exception for numeric types 
    if (NumberTypeHelper.isBaseTypeZero(leftType)) {
      return;
    }
    if (NumberTypeHelper.isBaseTypeZero(rightType)) {
      return;
    }

    TypingHelper.ensureTypeComparability(leftType, rightType, new _FunctionTypes._return_P2_E0<Boolean, SNode, SNode>() {
      public Boolean invoke(SNode left, SNode right) {
        // Test against equals expression for primitive types (if no operation type of such type exists, there is probably no comparison to be made between the two types) 
        SNode opType = typeCheckingContext.getOverloadedOperationType(SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cc6dc9L, "org.iets3.core.expr.base.structure.EqualsExpression")), left, right, new IRuleConflictWarningProducer() {
          public void produceWarning(String modelId, String ruleId) {
            typeCheckingContext.reportWarning(SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cc6dc9L, "org.iets3.core.expr.base.structure.EqualsExpression")), "coflicting rules for overloaded operation type", modelId, ruleId, null, new NodeMessageTarget());

          }
        });

        return opType != null && !(TypecheckingFacade.getFromContext().isSubtype(opType, createRuntimeErrorType_u2iiiw_b0a0a3a2a7a1()));
      }
    }, new _FunctionTypes._void_P2_E0<SNode, SNode>() {
      public void invoke(SNode left, SNode right) {
        errorStringCallback.invoke(rightName + " [" + BaseConcept__BehaviorDescriptor.getDetailedPresentation_id22G2W3WJ92t.invoke(rightType) + "] should be comparable to " + leftName + " [" + BaseConcept__BehaviorDescriptor.getDetailedPresentation_id22G2W3WJ92t.invoke(leftType) + "]");
      }
    });
  }

  private static SNode createRuntimeErrorType_u2iiiw_b0a0a3a2a7a1() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$Lm);
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Type$fA = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
    /*package*/ static final SConcept RuntimeErrorType$Lm = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, "jetbrains.mps.lang.typesystem.structure.RuntimeErrorType");
  }
}
