package jetbrains.mps.samples.Physics.genjs.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;

public class DependenciesSolver {
  private static final Logger LOG = LogManager.getLogger(DependenciesSolver.class);
  public static List<SNode> dependenciesOf(SNode simulation) {
    Map<SNode, List<SNode>> dependencies = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());

    // Retrieve dependencies 
    includeWorldInto(SLinkOperations.getTarget(SLinkOperations.getTarget(simulation, LINKS.world$Ang), LINKS.target$vT2z), dependencies);

    // Compute order 
    final List<SNode> selected = ListSequence.fromList(new ArrayList<SNode>());

    // Failsafe counter (prevent circular dependencies) 
    int iterations = 0;

    while (ListSequence.fromList(selected).count() < MapSequence.fromMap(dependencies).count() && iterations < MapSequence.fromMap(dependencies).count() + 1) {
      iterations++;
      MapSequence.fromMap(dependencies).where(new IWhereFilter<IMapping<SNode, List<SNode>>>() {
        public boolean accept(final IMapping<SNode, List<SNode>> entry) {
          // Select all entries 
          return !(ListSequence.fromList(selected).contains(entry.key())) && ListSequence.fromList(entry.value()).all(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              // With already selected deps (or self) 
              return entry.key() == it || ListSequence.fromList(selected).contains(it);
            }
          });
        }
      }).visitAll(new IVisitor<IMapping<SNode, List<SNode>>>() {
        public void visit(IMapping<SNode, List<SNode>> it) {
          // And add it to the list 
          ListSequence.fromList(selected).addElement(it.key());
        }
      });
      LoggingRuntime.logMsgView(Level.INFO, selected, DependenciesSolver.class, null, null);
      LoggingRuntime.logMsgView(Level.INFO, MapSequence.fromMap(dependencies).where(new IWhereFilter<IMapping<SNode, List<SNode>>>() {
        public boolean accept(IMapping<SNode, List<SNode>> it) {
          return !(ListSequence.fromList(selected).contains(it.key()));
        }
      }).toListSequence().toString(), DependenciesSolver.class, null, null);
    }

    return selected;
  }

  private static void includeWorldInto(SNode world, final Map<SNode, List<SNode>> dependencies) {
    if (MapSequence.fromMap(dependencies).containsKey(world)) {
      return;
    }

    final List<SNode> dependsOn = createDependencyOn(world, dependencies);

    ListSequence.fromList(SLinkOperations.getChildren(world, LINKS.objects$E3a8)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        if ((SLinkOperations.getTarget(it, LINKS.parent$k$qA) != null)) {
          includeAbstractObjectInto(SLinkOperations.getTarget(SLinkOperations.getTarget(it, LINKS.parent$k$qA), LINKS.target$kzX3), dependencies);
          ListSequence.fromList(dependsOn).addElement(SLinkOperations.getTarget(SLinkOperations.getTarget(it, LINKS.parent$k$qA), LINKS.target$kzX3));
        }
      }
    });

    // Other worlds 
    ListSequence.fromList(SLinkOperations.getChildren(world, LINKS.includes$Atsz)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        includeWorldInto(SLinkOperations.getTarget(SLinkOperations.getTarget(it, LINKS.world$Tjdz), LINKS.target$vT2z), dependencies);
        ListSequence.fromList(dependsOn).addElement(SLinkOperations.getTarget(SLinkOperations.getTarget(it, LINKS.world$Tjdz), LINKS.target$vT2z));
      }
    });

    // Abstract forces 
    includeForcesOfInto(world, dependencies, dependsOn);

  }

  private static void includeAbstractObjectInto(SNode node, Map<SNode, List<SNode>> dependencies) {
    if (MapSequence.fromMap(dependencies).containsKey(node)) {
      return;
    }

    List<SNode> innerDeps = createDependencyOn(node, dependencies);

    if ((SLinkOperations.getTarget(node, LINKS.parent$k$qA) != null)) {
      ListSequence.fromList(innerDeps).addElement(SLinkOperations.getTarget(SLinkOperations.getTarget(node, LINKS.parent$k$qA), LINKS.target$kzX3));
      includeAbstractObjectInto(SLinkOperations.getTarget(SLinkOperations.getTarget(node, LINKS.parent$k$qA), LINKS.target$kzX3), dependencies);
    }

    includeForcesOfInto(node, dependencies, innerDeps);
  }

  private static void includeForcesOfInto(SNode node, final Map<SNode, List<SNode>> dependencies, final List<SNode> parentDeps) {
    ListSequence.fromList(SNodeOperations.getNodeDescendants(node, CONCEPTS.AbstractForceCall$fJ, false, new SAbstractConcept[]{})).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        ListSequence.fromList(parentDeps).addElement(SLinkOperations.getTarget(it, LINKS.force$geAY));

        // Prevent infinite recursive call 
        if (!(MapSequence.fromMap(dependencies).containsKey(SLinkOperations.getTarget(it, LINKS.force$geAY)))) {
          List<SNode> innerDeps = createDependencyOn(SLinkOperations.getTarget(it, LINKS.force$geAY), dependencies);

          // In case of nested calls 
          includeForcesOfInto(SLinkOperations.getTarget(it, LINKS.force$geAY), dependencies, innerDeps);
        }
      }
    });
  }

  private static List<SNode> createDependencyOn(SNode node, Map<SNode, List<SNode>> dependencies) {
    List<SNode> innerDeps = ListSequence.fromList(new ArrayList<SNode>());
    MapSequence.fromMap(dependencies).put(node, innerDeps);
    return innerDeps;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink world$Ang = MetaAdapterFactory.getContainmentLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x6b7f605cb32fba58L, 0x3cd406ea6def9f02L, "world");
    /*package*/ static final SReferenceLink target$vT2z = MetaAdapterFactory.getReferenceLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x5d5cbb75843c860L, 0x5d5cbb75843c861L, "target");
    /*package*/ static final SContainmentLink objects$E3a8 = MetaAdapterFactory.getContainmentLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x6b7f605cb3278f40L, 0x6b7f605cb3278f46L, "objects");
    /*package*/ static final SContainmentLink parent$k$qA = MetaAdapterFactory.getContainmentLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x1441545e2a5b1e43L, 0x1441545e2a5b1e47L, "parent");
    /*package*/ static final SReferenceLink target$kzX3 = MetaAdapterFactory.getReferenceLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x1441545e2a5b1e44L, 0x1441545e2a5b1e45L, "target");
    /*package*/ static final SContainmentLink includes$Atsz = MetaAdapterFactory.getContainmentLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x6b7f605cb3278f40L, 0x3cd406ea6df3437dL, "includes");
    /*package*/ static final SContainmentLink world$Tjdz = MetaAdapterFactory.getContainmentLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x3cd406ea6df343a0L, 0x3cd406ea6df343a1L, "world");
    /*package*/ static final SReferenceLink force$geAY = MetaAdapterFactory.getReferenceLink(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x14f63a14438be6a0L, 0x3126c7c72473eb96L, "force");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractForceCall$fJ = MetaAdapterFactory.getConcept(0xbe81eb124eda4d0eL, 0x89be7493500ab874L, 0x14f63a14438be6a0L, "jetbrains.mps.samples.Physics.structure.AbstractForceCall");
  }
}
