package org.mar9000.mps.ecmascript.bundler.plugin;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class DependenciesSolver {
  public static List<SNode> dependenciesOf(SNode root) {
    Map<SNode, List<SNode>> dependencies = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());

    // Retrieve dependencies
    fetchDependenciesOf(root, dependencies);

    // Compute order
    final List<SNode> selected = ListSequence.fromList(new ArrayList<SNode>());

    // Failsafe counter (prevent circular dependencies issues)
    int iterations = 0;

    while (ListSequence.fromList(selected).count() < MapSequence.fromMap(dependencies).count() && iterations < MapSequence.fromMap(dependencies).count() + 1) {
      iterations++;
      MapSequence.fromMap(dependencies).where(new IWhereFilter<IMapping<SNode, List<SNode>>>() {
        public boolean accept(final IMapping<SNode, List<SNode>> entry) {
          // Select all entries
          return !(ListSequence.fromList(selected).contains(entry.key())) && ListSequence.fromList(entry.value()).all(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              // With already selected deps (or self)
              return entry.key() == it || ListSequence.fromList(selected).contains(it);
            }
          });
        }
      }).sort(new ISelector<IMapping<SNode, List<SNode>>, String>() {
        public String select(IMapping<SNode, List<SNode>> it) {
          return SPropertyOperations.getString(it.key(), PROPS.name$MnvL);
        }
      }, true).visitAll(new IVisitor<IMapping<SNode, List<SNode>>>() {
        public void visit(IMapping<SNode, List<SNode>> it) {
          // And add it to the list
          ListSequence.fromList(selected).addElement(it.key());
        }
      });
    }

    return selected;
  }

  private static void fetchDependenciesOf(SNode program, final Map<SNode, List<SNode>> dependencies) {
    if (MapSequence.fromMap(dependencies).containsKey(program)) {
      return;
    }

    final List<SNode> dependsOn = createDependencyOn(program, dependencies);

    ListSequence.fromList(SNodeOperations.getNodeDescendants(program, CONCEPTS.JSInjectModule$wX, true, new SAbstractConcept[]{})).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        ListSequence.fromList(dependsOn).addElement(SLinkOperations.getTarget(it, LINKS.module$xfZi));
        fetchDependenciesOf(SLinkOperations.getTarget(it, LINKS.module$xfZi), dependencies);
      }
    });
  }

  private static List<SNode> createDependencyOn(SNode node, Map<SNode, List<SNode>> dependencies) {
    List<SNode> innerDeps = ListSequence.fromList(new ArrayList<SNode>());
    MapSequence.fromMap(dependencies).put(node, innerDeps);
    return innerDeps;
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept JSInjectModule$wX = MetaAdapterFactory.getConcept(0x8d94c08e449e484bL, 0x9e9ef3e97c8df28aL, 0x159ecb3ed37c0e17L, "org.mar9000.mps.ecmascript.bundler.structure.JSInjectModule");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink module$xfZi = MetaAdapterFactory.getReferenceLink(0x8d94c08e449e484bL, 0x9e9ef3e97c8df28aL, 0x159ecb3ed37c0e17L, 0x159ecb3ed37f24c3L, "module");
  }
}
