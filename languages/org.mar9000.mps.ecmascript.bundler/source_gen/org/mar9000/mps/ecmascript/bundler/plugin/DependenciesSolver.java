package org.mar9000.mps.ecmascript.bundler.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class DependenciesSolver {
  private static final Logger LOG = LogManager.getLogger(DependenciesSolver.class);
  public static List<SNode> dependenciesOf(SNode root) {
    Map<SNode, List<SNode>> dependencies = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());

    // Retrieve dependencies 
    fetchDependenciesOf(root, dependencies);

    // Compute order 
    final List<SNode> selected = ListSequence.fromList(new ArrayList<SNode>());

    // Failsafe counter (prevent circular dependencies issues) 
    int iterations = 0;

    while (ListSequence.fromList(selected).count() < MapSequence.fromMap(dependencies).count() && iterations < MapSequence.fromMap(dependencies).count() + 1) {
      iterations++;
      MapSequence.fromMap(dependencies).where(new IWhereFilter<IMapping<SNode, List<SNode>>>() {
        public boolean accept(final IMapping<SNode, List<SNode>> entry) {
          // Select all entries 
          return !(ListSequence.fromList(selected).contains(entry.key())) && ListSequence.fromList(entry.value()).all(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              // With already selected deps (or self) 
              return entry.key() == it || ListSequence.fromList(selected).contains(it);
            }
          });
        }
      }).visitAll(new IVisitor<IMapping<SNode, List<SNode>>>() {
        public void visit(IMapping<SNode, List<SNode>> it) {
          // And add it to the list 
          ListSequence.fromList(selected).addElement(it.key());
        }
      });
      LoggingRuntime.logMsgView(Level.INFO, selected, DependenciesSolver.class, null, null);
      LoggingRuntime.logMsgView(Level.INFO, MapSequence.fromMap(dependencies).where(new IWhereFilter<IMapping<SNode, List<SNode>>>() {
        public boolean accept(IMapping<SNode, List<SNode>> it) {
          return !(ListSequence.fromList(selected).contains(it.key()));
        }
      }).toListSequence().toString(), DependenciesSolver.class, null, null);
    }

    return selected;
  }

  private static void fetchDependenciesOf(SNode program, final Map<SNode, List<SNode>> dependencies) {
    if (MapSequence.fromMap(dependencies).containsKey(program)) {
      return;
    }

    final List<SNode> dependsOn = createDependencyOn(program, dependencies);

    ListSequence.fromList(SNodeOperations.getNodeDescendants(program, CONCEPTS.JSInjectModule$wX, true, new SAbstractConcept[]{})).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        ListSequence.fromList(dependsOn).addElement(SLinkOperations.getTarget(it, LINKS.module$xfZi));
        fetchDependenciesOf(SLinkOperations.getTarget(it, LINKS.module$xfZi), dependencies);
      }
    });
  }

  private static List<SNode> createDependencyOn(SNode node, Map<SNode, List<SNode>> dependencies) {
    List<SNode> innerDeps = ListSequence.fromList(new ArrayList<SNode>());
    MapSequence.fromMap(dependencies).put(node, innerDeps);
    return innerDeps;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept JSInjectModule$wX = MetaAdapterFactory.getConcept(0x8d94c08e449e484bL, 0x9e9ef3e97c8df28aL, 0x159ecb3ed37c0e17L, "org.mar9000.mps.ecmascript.bundler.structure.JSInjectModule");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink module$xfZi = MetaAdapterFactory.getReferenceLink(0x8d94c08e449e484bL, 0x9e9ef3e97c8df28aL, 0x159ecb3ed37c0e17L, 0x159ecb3ed37f24c3L, "module");
  }
}
