package jetbrains.mps.samples.Physics.java.runtime.objects.rendering;

/*Generated by MPS */

import org.ode4j.ode.DGeom;
import com.badlogic.gdx.graphics.g3d.ModelInstance;
import jetbrains.mps.samples.Physics.java.runtime.objects.World;
import org.ode4j.ode.DMass;
import org.ode4j.ode.DBody;
import jetbrains.mps.samples.Physics.java.runtime.objects.PhysicalEntity;
import org.ode4j.math.DVector3C;
import org.ode4j.math.DVector3;

public abstract class Fixture {
  protected DGeom geometry;
  protected Texture texture;
  public ModelInstance modelInstance;
  private boolean emitLight;
  protected World world;

  private float scaleCache;

  public Fixture(World world, Texture texture) {
    this.world = world;
    this.texture = texture;
  }

  public void setup(float scale) {
    scaleCache = scale;
  }

  /**
   * Construct mass adequate to fixture implementation
   * @return mass with appropriate representation
   */
  protected abstract DMass buildMass(double massValue);
  public void bindToBody(DBody body, double massValue) {
    // Build and apply mass
    DMass mass = buildMass(massValue);
    body.setMass(mass);
    // Set the body of this fixture geometry
    geometry = buildGeometry();
    geometry.setBody(body);
  }
  public DGeom getGeometry() {
    return geometry;
  }

  public abstract double getVolume();
  protected abstract void setVolume(double volume);
  public abstract DGeom buildGeometry();

  /**
   * Take the given fixture and merge its content into this fixture
   */
  public void mergeWith(Fixture fixture, PhysicalEntity targetEntity) {
    DBody body = geometry.getBody();
    DBody otherBody = fixture.getGeometry().getBody();

    // Keep previous mass
    double thisMass = body.getMass().getMass();
    double otherMass = otherBody.getMass().getMass();

    // Destroy previous previous
    geometry.destroy();

    // Set volume to the sum of both
    double volume = getVolume() + fixture.getVolume();
    this.setVolume(volume);

    // Choose resulting texture
    double thisRatio = thisMass / (otherMass + thisMass);
    double otherRatio = 1 - thisRatio;
    this.texture = texture.mergeWith(fixture.getTexture(), (float) thisRatio);

    //  Setup again (to apply volume and texture)
    this.setup(scaleCache);

    DVector3C thisVel = body.getLinearVel();
    DVector3C otherVel = otherBody.getLinearVel();
    body.setLinearVel(new DVector3(thisVel.get0() * thisRatio + otherVel.get0() * otherRatio, thisVel.get1() * thisRatio + otherVel.get1() * otherRatio, thisVel.get2() * thisRatio + otherVel.get2() * otherRatio));

    // TODO merge angular velocity?

    // Rebuild geometry and apply to body
    this.bindToBody(body, thisMass + otherMass);
    targetEntity.setMass(thisMass + otherMass);
  }

  public boolean doEmitLight() {
    return this.emitLight;
  }
  public void setEmitLight(boolean emitLight) {
    this.emitLight = emitLight;
  }

  public Texture getTexture() {
    return this.texture;
  }
}
