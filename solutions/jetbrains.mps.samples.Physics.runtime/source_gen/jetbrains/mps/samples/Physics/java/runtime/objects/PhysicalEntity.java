package jetbrains.mps.samples.Physics.java.runtime.objects;

/*Generated by MPS */

import jetbrains.mps.samples.Physics.java.common.vectors.VectorLike;
import org.ode4j.ode.DBody;
import jetbrains.mps.samples.Physics.java.runtime.objects.rendering.Fixture;
import jetbrains.mps.samples.Physics.java.runtime.objects.forces.CollisionReaction;
import java.math.BigDecimal;
import java.util.ArrayList;
import jetbrains.mps.samples.Physics.java.runtime.objects.forces.Force;
import org.ode4j.ode.OdeHelper;
import org.ode4j.math.DVector3;
import processing.core.PApplet;
import org.ode4j.math.DVector3C;
import java.util.List;
import jetbrains.mps.samples.Physics.java.common.vectors.BigDecimalHelper;
import jetbrains.mps.samples.Physics.java.runtime.VectorHelper;
import jetbrains.mps.samples.Physics.java.runtime.objects.rendering.builder.FixtureBuilder;

public class PhysicalEntity<T extends SystemScope> extends VectorLike implements EntityLike {
  private DBody body;
  private World world;
  private Fixture fixture;

  private CollisionReaction collisionReaction = CollisionReaction.BOUNCE;

  private BigDecimal massCached;
  private boolean disabled = false;

  /**
   * Forces applied on the entity
   */
  private ArrayList<Force> forces = new ArrayList();
  public PhysicalEntity(World world) {
    this.world = world;
    // Creating body 
    body = OdeHelper.createBody(world.getWorld());
  }


  /**
   * Remove entity from the world
   */
  public void disable() {
    fixture.getGeometry().disable();
    body.disable();
    this.disabled = true;
  }

  public boolean isDisabled() {
    return this.disabled;
  }

  public void applyForces(long time) {
    for (Force force : forces) {
      body.addForce((DVector3) force.compute(world, null, this, time));
    }
  }
  public void applyLights(PApplet ctx) {
    if (fixture.doEmitLight()) {
      DVector3C position = body.getPosition();
      ctx.pointLight(255, 255, 255, (float) position.get0(), (float) position.get1(), (float) position.get2());
    }
  }
  public void render(PApplet ctx) {
    DVector3C position = body.getPosition();
    ctx.pushMatrix();
    ctx.translate((float) position.get0(), (float) position.get1(), (float) position.get2());
    fixture.render(ctx);
    ctx.popMatrix();
  }
  public void setFixture(Fixture fixture) {
    this.fixture = fixture;
  }
  public DBody getBody() {
    return body;
  }
  public List<Force> getForces() {
    return forces;
  }

  public void setMass(Number value) {
    massCached = BigDecimalHelper.of(value);
  }

  /**
   * Create mass representation internally
   */
  public void bindFixture() {
    // Creating mass representation 
    fixture.bindToBody(body, massCached.doubleValue());
  }

  @Override
  public BigDecimal getX() {
    return BigDecimal.valueOf(this.getBody().getPosition().get0());
  }
  @Override
  public BigDecimal getY() {
    return BigDecimal.valueOf(this.getBody().getPosition().get1());
  }
  @Override
  public BigDecimal getZ() {
    return BigDecimal.valueOf(this.getBody().getPosition().get2());
  }

  public BigDecimal getMass() {
    if (massCached == null) {
      massCached = BigDecimal.valueOf(body.getMass().getMass());
    }
    return massCached;
  }

  public VectorLike getPosition() {
    return VectorHelper.internalFromDVector3C(getBody().getPosition());
  }

  public VectorLike getVelocity() {
    return VectorHelper.internalFromDVector3C(getBody().getLinearVel());
  }


  public CollisionReaction getCollisionReaction() {
    return this.collisionReaction;
  }
  public void setCollisionReaction(CollisionReaction collisionReaction) {
    this.collisionReaction = collisionReaction;
  }
  public boolean hasReactionPriority(PhysicalEntity cmp) {
    //  Either highest priority or equal priority but greater mass 
    return this.collisionReaction.priority > cmp.getCollisionReaction().priority || (this.collisionReaction.priority == cmp.getCollisionReaction().priority && getMass().compareTo(cmp.getMass()) >= 0);
  }
  public void init(T scope, World world, FixtureBuilder fixtureProperties) {
  }
  public Fixture getFixture() {
    return this.fixture;
  }
}
