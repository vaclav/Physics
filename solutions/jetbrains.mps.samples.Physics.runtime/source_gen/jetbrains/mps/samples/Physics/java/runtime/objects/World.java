package jetbrains.mps.samples.Physics.java.runtime.objects;

/*Generated by MPS */

import org.ode4j.ode.DGeom;
import org.ode4j.ode.DWorld;
import org.ode4j.ode.DSpace;
import org.ode4j.ode.DJointGroup;
import java.util.ArrayList;
import java.util.HashMap;
import org.ode4j.ode.DBody;
import org.ode4j.ode.OdeHelper;
import org.ode4j.ode.internal.DxGeom;
import processing.core.PApplet;
import java.util.List;

public class World implements DGeom.DNearCallback {
  private final DWorld world;
  private final DSpace space;
  private final DJointGroup jointGroup;
  private final ArrayList<PhysicalEntity> entities = new ArrayList();
  private final HashMap<DBody, PhysicalEntity> reverseEntities = new HashMap();

  private boolean paused;
  private double time;
  private final double timeStep;

  /**
   * Create world with given simulation time. The simulation time is the time elapsed in the simulation
   * during a second in the real world.
   */
  public World(double secondDuration) {
    this.timeStep = secondDuration / 60;
    this.time = 0;
    this.paused = false;
    this.world = OdeHelper.createWorld();
    this.space = OdeHelper.createHashSpace();
    this.jointGroup = OdeHelper.createJointGroup();

    // Init colliders 
    DxGeom.dInitColliders();
  }

  /**
   * Perform a simulation step
   */
  public void step() {
    if (paused) {
      return;
    }

    space.collide(null, this);
    time += timeStep;

    for (PhysicalEntity entity : entities) {
      entity.applyForces(time);
    }

    world.quickStep(timeStep);
    jointGroup.empty();
  }

  /**
   * Handle collisions between objects in space
   * 
   * @param data collision data used internally by ODE4J
   * @param g1 first object
   * @param g2 second object
   */
  @Override
  public void call(Object data, DGeom g1, DGeom g2) {
    if (g1 instanceof DSpace || g2 instanceof DSpace) {
      OdeHelper.spaceCollide2(g1, g2, data, this);
      return;
    }
    PhysicalEntity e1 = reverseEntities.get(g1.getBody());
    PhysicalEntity e2 = reverseEntities.get(g2.getBody());

    PhysicalEntity first = (e1.hasReactionPriority(e2) ? e1 : e2);
    PhysicalEntity second = (first == e1 ? e2 : e1);
    DGeom firstGeom = (first == e1 ? g1 : g2);
    DGeom secondGeom = (firstGeom == g1 ? g2 : g1);

    // React with the reaction with highest priority first 
    first.getCollisionReaction().method.react(this, first, firstGeom, second, secondGeom);

    // If the first reaction allow the second one to be performed aswell 
    if (!(first.getCollisionReaction().preventOtherReaction) && first.getCollisionReaction() != second.getCollisionReaction()) {
      second.getCollisionReaction().method.react(this, second, secondGeom, first, firstGeom);
    }
  }

  /**
   *  Render the world
   * 
   *  @param ctx applet context
   */
  public void render(PApplet ctx) {
    for (PhysicalEntity entity : entities) {
      entity.applyLights(ctx);
    }
    for (PhysicalEntity entity : entities) {
      entity.render(ctx);
    }
  }

  public void addEntity(PhysicalEntity entity) {
    entities.add(entity);
    reverseEntities.put(entity.getBody(), entity);
  }
  public DSpace getSpace() {
    return space;
  }
  public DWorld getWorld() {
    return world;
  }
  public List<PhysicalEntity> getEntities() {
    return entities;
  }

  public DJointGroup getJointGroup() {
    return this.jointGroup;
  }


  public boolean isPaused() {
    return this.paused;
  }
  public void setPaused(boolean paused) {
    this.paused = paused;
  }
}
