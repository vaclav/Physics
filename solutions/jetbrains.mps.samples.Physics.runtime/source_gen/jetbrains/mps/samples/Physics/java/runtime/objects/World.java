package jetbrains.mps.samples.Physics.java.runtime.objects;

/*Generated by MPS */

import org.ode4j.ode.DGeom;
import jetbrains.mps.samples.Physics.java.runtime.Renderable;
import org.ode4j.ode.DWorld;
import org.ode4j.ode.DSpace;
import org.ode4j.ode.DJointGroup;
import java.util.ArrayList;
import java.util.HashMap;
import org.ode4j.ode.DBody;
import com.badlogic.gdx.utils.TimeUtils;
import org.ode4j.ode.OdeHelper;
import org.ode4j.ode.internal.DxGeom;
import jetbrains.mps.samples.Physics.java.runtime.objects.forces.CollisionReaction;
import com.badlogic.gdx.graphics.g3d.Environment;
import com.badlogic.gdx.graphics.g3d.ModelBatch;
import jetbrains.mps.samples.Physics.java.common.vectors.VectorLike;
import java.util.List;

public class World implements DGeom.DNearCallback, Renderable {
  private static boolean colliderInitialized = false;

  private final DWorld world;
  private final DSpace space;
  private final DJointGroup jointGroup;
  private final ArrayList<PhysicalEntity> entities = new ArrayList();
  private final HashMap<DBody, PhysicalEntity> reverseEntities = new HashMap();

  private boolean paused;
  private double time;
  private final double timeStep;
  private long lastTime = TimeUtils.millis();
  /**
   * Create world with given simulation time. The simulation time is the time elapsed in the simulation
   * during a second in the real world.
   */
  public World(double secondDuration) {
    this.timeStep = secondDuration;
    this.time = 0;
    this.paused = false;
    this.world = OdeHelper.createWorld();
    this.space = OdeHelper.createHashSpace();
    this.jointGroup = OdeHelper.createJointGroup();

    // Init colliders
    if (!(colliderInitialized)) {
      colliderInitialized = true;
      DxGeom.dInitColliders();
    }
  }

  /**
   * Perform a simulation step
   */
  public void step() {
    if (paused) {
      return;
    }

    space.collide(null, this);
    double step = timeStep * TimeUtils.timeSinceMillis(lastTime) / 1000.f;
    time += step;
    lastTime = TimeUtils.millis();

    for (PhysicalEntity entity : entities) {
      entity.applyForces(time);
    }

    world.quickStep(step);
    jointGroup.empty();
  }

  /**
   * Handle collisions between objects in space
   * 
   * @param data collision data used internally by ODE4J
   * @param g1 first object
   * @param g2 second object
   */
  @Override
  public void call(Object data, DGeom g1, DGeom g2) {
    if (g1 instanceof DSpace || g2 instanceof DSpace) {
      OdeHelper.spaceCollide2(g1, g2, data, this);
      return;
    }
    PhysicalEntity e1 = reverseEntities.get(g1.getBody());
    PhysicalEntity e2 = reverseEntities.get(g2.getBody());

    final PhysicalEntity first = (CollisionReaction.hasPriority(e1, e2) ? e1 : e2);
    final PhysicalEntity second = (first == e1 ? e2 : e1);
    final DGeom firstGeom = (first == e1 ? g1 : g2);
    final DGeom secondGeom = (firstGeom == g1 ? g2 : g1);

    // React with the reaction with highest priority first
    final CollisionReaction firstReaction = first.properties().getCollisionReaction();
    firstReaction.react(this, first, firstGeom, second, secondGeom);

    // If the first reaction allow the second one to be performed as well
    final CollisionReaction secondReaction = second.properties().getCollisionReaction();
    if (!(firstReaction.preventDifferentReaction()) && !(firstReaction.equals(secondReaction))) {
      secondReaction.react(this, second, secondGeom, first, firstGeom);
    }

    // Pause world if required
    if (first.properties().isPauseOnCollision() || second.properties().isPauseOnCollision()) {
      this.setPaused(true);
    }
  }


  @Override
  public void setup(Environment env, float scale) {
    for (PhysicalEntity entity : entities) {
      entity.setup(env, scale);
    }
  }

  @Override
  public void render(ModelBatch batch, Environment environment, float scale, VectorLike scaledOffset) {
    for (PhysicalEntity entity : entities) {
      entity.updateLights(scale, scaledOffset);
    }

    for (PhysicalEntity entity : entities) {
      entity.render(batch, environment, scale, scaledOffset);
    }
  }

  public void addEntity(PhysicalEntity entity) {
    entities.add(entity);
    reverseEntities.put(entity.getBody(), entity);
  }
  public DSpace getSpace() {
    return space;
  }
  public DWorld getWorld() {
    return world;
  }
  public List<PhysicalEntity> getEntities() {
    return entities;
  }

  public DJointGroup getJointGroup() {
    return this.jointGroup;
  }


  public boolean isPaused() {
    return this.paused;
  }
  public void setPaused(boolean paused) {
    this.paused = paused;
  }


  public double getTime() {
    return this.time;
  }
}
