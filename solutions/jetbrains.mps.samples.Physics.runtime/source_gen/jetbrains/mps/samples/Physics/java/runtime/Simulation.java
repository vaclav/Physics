package jetbrains.mps.samples.Physics.java.runtime;

/*Generated by MPS */

import com.badlogic.gdx.ApplicationListener;
import jetbrains.mps.samples.Physics.java.runtime.objects.World;
import jetbrains.mps.samples.Physics.java.runtime.objects.rendering.MetricsRenderer;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g3d.ModelBatch;
import com.badlogic.gdx.graphics.g3d.Environment;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import jetbrains.mps.references.Reference;
import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import jetbrains.mps.samples.Physics.java.common.vectors.VectorLike;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.math.Matrix4;
import jetbrains.mps.samples.Physics.java.common.vectors.InternalVector;

public abstract class Simulation implements ApplicationListener {
  protected World world;
  protected double simulationSpeed;
  protected float renderScale;
  protected MetricsRenderer metricsRenderer;
  protected OrthographicCamera camera;
  private ModelBatch modelBatch;
  private Environment environment;
  private SpriteBatch spriteBatch;
  private FitViewport viewport;
  private ShapeRenderer shapeRenderer;

  public int getOffsetX() {
    return viewport.getScreenX();
  }
  private void _setOffsetX(int value) {
    viewport.setScreenX(value);
  }
  public int setOffsetX(int value) {
    _setOffsetX(value);
    return value;
  }
  public Reference<Integer> refToOffsetX() {
    return new Reference<Integer>() {
      public Integer get() {
        return getOffsetX();
      }
      public void set(Integer value) {
        _setOffsetX(value);
      }
    };
  }

  public Simulation(double simulationSpeed, float renderScale) {
    this.simulationSpeed = simulationSpeed;
    this.renderScale = renderScale;
  }

  @Override
  public void create() {
    this.environment = new Environment();
    environment.set(new ColorAttribute(ColorAttribute.AmbientLight, 1.0f, 1.0f, 1.0f, 0.5f));

    this.modelBatch = new ModelBatch();
    this.spriteBatch = new SpriteBatch();
    this.shapeRenderer = new ShapeRenderer();

    this.camera = new OrthographicCamera();
    camera.near = 1.f;
    camera.far = Float.MAX_VALUE / 100;
    camera.position.set(0, 0, 0);

    viewport = new FitViewport(camera.viewportWidth, camera.viewportHeight, camera);

    world = new World(simulationSpeed);
    init(world);

    metricsRenderer = new MetricsRenderer(new BitmapFont());

    world.setup(environment, renderScale);
  }


  @Override
  public void resize(int width, int height) {
    viewport.setWorldSize(width, height);
    viewport.setScreenSize(width, height);
    camera.viewportWidth = width;
    camera.viewportHeight = height;
  }

  @Override
  public void render() {
    // Setting camera properly (at 0,0,0 but adding offset to every displayed item)
    VectorLike position = getCameraPosition().mul(renderScale);
    VectorLike focus = getCameraFocus().mul(renderScale).minus(position);

    camera.lookAt(VectorHelper.toVector3(focus));
    viewport.apply(false);

    modelBatch.begin(camera);
    world.render(modelBatch, environment, renderScale, position.mul(-1));
    modelBatch.end();

    world.step();

    Gdx.gl.glDisable(GL20.GL_DEPTH_TEST);
    Gdx.gl.glDepthMask(false);

    Matrix4 projection = camera.combined.translate(-camera.viewportWidth / 2, -camera.viewportHeight / 2, 0);
    spriteBatch.setProjectionMatrix(projection);
    shapeRenderer.setProjectionMatrix(projection);

    spriteBatch.begin();
    metricsRenderer.renderDefault(world, spriteBatch);
    this.renderMetrics(spriteBatch, shapeRenderer);
    spriteBatch.end();

    Gdx.gl.glDepthMask(true);
    Gdx.gl.glEnable(GL20.GL_DEPTH_TEST);
  }

  public VectorLike getCameraPosition() {
    return new InternalVector(camera.viewportWidth / 2, camera.viewportHeight / 2, (camera.viewportHeight / 2) / Math.tan(Math.PI * 30 / 180));
  }

  public VectorLike getCameraFocus() {
    return new InternalVector(camera.viewportWidth / 2, camera.viewportHeight / 2, 0);
  }

  protected abstract void init(World world);
  protected abstract void renderMetrics(SpriteBatch ctx, ShapeRenderer shapeRenderer);

  public boolean isPaused() {
    return world.isPaused();
  }

  @Override
  public void pause() {
    world.setPaused(true);
  }
  @Override
  public void resume() {
    world.setPaused(false);
  }
  @Override
  public void dispose() {
    modelBatch.dispose();
    spriteBatch.dispose();
  }
}
