package jetbrains.mps.samples.Physics.java.runtime;

/*Generated by MPS */

import com.badlogic.gdx.ApplicationListener;
import jetbrains.mps.references.Reference;
import jetbrains.mps.samples.Physics.java.runtime.objects.World;
import jetbrains.mps.samples.Physics.java.runtime.objects.rendering.MetricsRenderer;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g3d.ModelBatch;
import com.badlogic.gdx.graphics.g3d.Environment;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import jetbrains.mps.samples.Physics.java.common.vectors.VectorLike;
import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import jetbrains.mps.samples.Physics.java.common.vectors.InternalVector;

public abstract class Simulation implements ApplicationListener {
  private int myOffsetX;
  public int getOffsetX() {
    return this.myOffsetX;
  }
  private void _setOffsetX(int value) {
    this.myOffsetX = value;
  }
  public int setOffsetX(int value) {
    _setOffsetX(value);
    return value;
  }
  public Reference<Integer> refToOffsetX() {
    return new Reference<Integer>() {
      public Integer get() {
        return getOffsetX();
      }
      public void set(Integer value) {
        _setOffsetX(value);
      }
    };
  }
  protected World world;
  protected double simulationSpeed;
  protected float renderScale;
  protected MetricsRenderer metricsRenderer;
  protected OrthographicCamera camera;
  protected ModelBatch modelBatch = new ModelBatch();
  protected Environment environment = new Environment();


  public Simulation(double simulationSpeed, float renderScale) {
    this.simulationSpeed = simulationSpeed;
    this.renderScale = renderScale;

    this.camera = new OrthographicCamera();
    camera.up.set(Vector3.Y);
    camera.near = 1.f;
    camera.far = Float.MAX_VALUE / 100;
  }

  @Override
  public void create() {
    world = new World(simulationSpeed);
    init(world);

    metricsRenderer = new MetricsRenderer(new BitmapFont());

    world.setup(renderScale);
  }


  @Override
  public void resize(int width, int height) {
    camera.viewportWidth = width;
    camera.viewportHeight = height;
  }

  @Override
  public void render() {
    Gdx.gl.glViewport(getOffsetX(), 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
    Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);

    // Setting camera properly (at 0,0,0 but adding offset to every displayed item)
    VectorLike position = getCameraPosition().mul(renderScale);
    VectorLike focus = getCameraFocus().mul(renderScale).minus(position);

    camera.position.set(VectorHelper.toVector3(position));
    camera.lookAt(VectorHelper.toVector3(focus));
    camera.update();

    world.render(modelBatch, environment, renderScale, position.mul(-1));
    world.step();

    // set ambient light to black
    environment.set(new ColorAttribute(ColorAttribute.AmbientLight, new Color(0.0f, 0.0f, 0.0f, 1.0f)));
    SpriteBatch batch = new SpriteBatch();

    Gdx.gl.glDisable(GL20.GL_DEPTH_TEST);
    Gdx.gl.glDepthMask(false);

    metricsRenderer.renderDefault(world, batch);
    this.renderMetrics(batch);

    Gdx.gl.glDepthMask(true);
    Gdx.gl.glEnable(GL20.GL_DEPTH_TEST);
  }

  public VectorLike getCameraPosition() {
    return new InternalVector(camera.viewportWidth / 2, camera.viewportHeight / 2, (camera.viewportHeight / 2) / Math.tan(Math.PI * 30 / 180));
  }

  public VectorLike getCameraFocus() {
    return new InternalVector(camera.viewportWidth / 2, camera.viewportHeight / 2, 0);
  }

  protected abstract void init(World world);
  protected abstract void renderMetrics(SpriteBatch ctx);

  public boolean isPaused() {
    return world.isPaused();
  }

  @Override
  public void pause() {
    world.setPaused(true);
  }
  @Override
  public void resume() {
    world.setPaused(false);
  }
  @Override
  public void dispose() {
  }
}
